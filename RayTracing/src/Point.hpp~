#ifndef POINT_H_
#define POINT_H_

#include <stdint.h>

#include <algorithm>
#include <array>
#include <cmath>
#include <iostream>
#include <numbers>
#include <ranges>
#include <type_traits>

/*
  t in R
  r in R+
  theta in [0,pi]
  phi in [0,2pi)
 */
enum PolAx { r = 1, phi = 2, theta = 3 };
enum Ax { t = 0, x = 1, y = 2, z = 3 };

template <typename DataType>
struct FVector;

template <typename DataType>
std::ostream& operator<<(std::ostream& os, const FVector<DataType>& FVec) {
    std::ranges::copy(FVec.components,
                      std::ostream_iterator<DataType>(os, "\t"));
    return os;
}

template <typename DataType = long double>
class FVector {
   public:
    constexpr static std::uint8_t size = 4;
    using VecType = std::array<DataType, size>;

    VecType components;
    // const std::span<DataType, size> span{components};
    constexpr FVector() : components({0, 0, 0, 0}){};

    constexpr FVector(DataType t, DataType x, DataType y, DataType z)
        : components({t, x, y, z}){};

    constexpr FVector(VecType v) : components(v){};

    /**
       this function is only approximate for small increments or for the vector
     in the locally flat spacetime manifold used during parallel transport
     **/
    FVector<DataType> operator+(const FVector<DataType>& FVec) const {
        /*
        DataType x =
            components[Ax::x] * std::cos(components[Ax::y]) *
                std::sin(components[Ax::z]) +
            FVec[Ax::x] * std::cos(FVec[Ax::y]) * std::sin(FVec[Ax::z]);
        DataType y =
            components[Ax::x] * std::sin(components[Ax::y]) *
                std::sin(components[Ax::z]) +
            FVec[Ax::x] * std::sin(FVec[Ax::y]) * std::sin(FVec[Ax::z]);
        DataType z = components[Ax::x] * std::cos(components[Ax::z]) +
                     FVec[Ax::x] * std::cos(FVec[Ax::z]);
        //
        // std::cout << *this << FVec << std::endl;

        // std::cout << x << " " << y << " " << z << std::endl;
        FVector<DataType> res{
            components[Ax::t] + FVec[Ax::t], std::sqrt(x * x + y * y + z * z),
            std::atan2(y, x), std::atan2(std::sqrt(x * x + y * y), z)};
        return res;
        */
        return FVector<DataType>{
            components[Ax::t] + FVec[Ax::t], components[Ax::x] + FVec[Ax::x],
            components[Ax::y] + FVec[Ax::y], components[Ax::z] + FVec[Ax::z]};
    }
    FVector<DataType> to_cart() {
        return FVector<DataType>{
            components[Ax::t],
            components[Ax::x] * std::cos(components[Ax::y]) *
                std::sin(components[Ax::z]),
            components[Ax::x] * std::sin(components[Ax::y]) *
                std::sin(components[Ax::z]),
            components[Ax::x] * std::cos(components[Ax::z])};
    }
    /*
    FVector<DataType> operator*(const FVector<DataType>& FVec) const {
        FVector<DataType> res{components};
        for (uint8_t i{}; i < size; ++i) {
            res[i] += FVec[i];
        }
        return res;
        }
    */
    FVector<DataType> operator*(const DataType scalar) const {
        if (std::is_same<DataType, long double>::value == false)
            std::cout << "PROBLEM" << std::endl;
        return FVector<DataType>{
            components[Ax::t] * scalar, components[Ax::x] * scalar,
            components[Ax::y] * scalar, components[Ax::z] * scalar};
    }
    /*
    void operator+=(const FVector<DataType>& FVec) {
        DataType x =
            components[Ax::x] * std::cos(components[Ax::y]) *
                std::sin(components[Ax::z]) +
            FVec[Ax::x] * std::cos(FVec[Ax::y]) * std::sin(FVec[Ax::z]);
        DataType y =
            components[Ax::x] * std::sin(components[Ax::y]) *
                std::sin(components[Ax::z]) +
            FVec[Ax::x] * std::sin(FVec[Ax::y]) * std::sin(FVec[Ax::z]);
        DataType z = components[Ax::x] * std::sin(components[Ax::z]) +
                     FVec[Ax::x] * std::sin(FVec[Ax::z]);
        // std::cout << x << " " << y << " " << z << std::endl;

        components[Ax::x] = std::sqrt(x * x + y * y + z * z);
        components[Ax::y] = std::atan2(y, x);
        components[Ax::z] = std::atan2(std::sqrt(x * x + y * y), z);
        components[Ax::t] += FVec[Ax::t];
    }
    */

    void to_polar() {
        DataType x = DataType{components[Ax::x]};
        DataType y = DataType{components[Ax::y]};
        DataType z = DataType{components[Ax::z]};
        components[PolAx::r] = std::sqrt(x * x + y * y + z * z);
        components[PolAx::phi] = std::atan2(y, x);
        components[PolAx::theta] = std::atan2(std::sqrt(x * x + y * y), z);

        this->check_bounds();
    }

    FVector<DataType> cross(const FVector<DataType>& FVec) {
        return FVector<DataType>{
            components[Ax::t],
            components[Ax::y] * FVec[Ax::z] - components[Ax::z] * FVec[Ax::y],
            components[Ax::z] * FVec[Ax::x] - components[Ax::x] * FVec[Ax::z],
            components[Ax::x] * FVec[Ax::y] - components[Ax::y] * FVec[Ax::x]};
    }
    DataType euclid_space_len() {
        return std::sqrt(components[Ax::x] * components[Ax::x] +
                         components[Ax::y] * components[Ax::y] +
                         components[Ax::z] * components[Ax::z]);
    }
    void euclid_mult(DataType scalar) {
        components[Ax::x] *= scalar;
        components[Ax::y] *= scalar;
        components[Ax::z] *= scalar;
    }

    void check_bounds() {
        if (components[Ax::x] < 0) {
            components[Ax::x] *= -1;
            components[Ax::y] += std::numbers::pi_v<DataType>;
        }

        while (components[Ax::y] < 0)
            components[Ax::y] += 2 * std::numbers::pi_v<DataType>;
        while (components[Ax::y] > 2 * std::numbers::pi_v<DataType>)
            components[Ax::y] -= 2 * std::numbers::pi_v<DataType>;

        while (components[Ax::z] <= 0)
            components[Ax::z] += std::numbers::pi_v<DataType>;
        while (components[Ax::z] >= std::numbers::pi_v<DataType>)
            components[Ax::z] -= std::numbers::pi_v<DataType>;
    }

    /*
      void operator*=(const FVector<DataType>& FVec) {
      components[Ax::t] *= scalar;
      components[Ax::x] *= scalar;
      };
    */
    DataType& operator[](std::uint8_t i) { return components[i]; }
    const DataType& operator[](std::uint8_t i) const { return components[i]; }
    friend std::ostream& operator<< <DataType>(std::ostream& os,
                                               const FVector<DataType>& FVec);
};
#endif
