#include <stdint.h>

#include <cmath>
#include <numbers>

#include "Point.hpp"
/*
  Constants
*/

constexpr double c{1};  // m/s
// xsconstexpr double G{6.6743e-11};        // m^3 kg^-1 s^-2
constexpr double rs{1};  // m
// constexpr double M{rs * c * c / (2 * G)};  // kg

template <typename T>
constexpr T metric(std::uint8_t mu, std::uint8_t nu, FVector<T> pos) {
    if (mu == Ax::t && nu == Ax::t) return (rs / pos[PolAx::r] - 1) * c * c;
    if (mu == PolAx::r && nu == PolAx::r) return 1 / (1 - rs / pos[PolAx::r]);
    if (mu == PolAx::phi && nu == PolAx::phi)
        return pos[PolAx::r] * pos[PolAx::r] * std::sin(pos[PolAx::theta]) *
               std::sin(pos[PolAx::theta]);
    if (mu == PolAx::theta && nu == PolAx::theta)
        return pos[PolAx::r] * pos[PolAx::r];
    return 0;
}

/*
  Christoffel Symbols for Schwarzschild metric
*/

template <typename T>
constexpr T chr_symbols(std::uint8_t mu, std::uint8_t alpha, std::uint8_t beta,
                        FVector<T> pos) {
    switch (mu) {
        case PolAx::r:
            if (alpha == PolAx::r && beta == PolAx::r)
                return rs / (2 * pos[PolAx::r] * (rs - pos[PolAx::r]));
            /*
            if ((alpha == Ax::x || beta == Ax::x) &&
                (alpha == Ax::y || beta == Ax::y))
                return;
            if ((alpha == Ax::x || beta == Ax::x) &&
                (alpha == Ax::z || beta == Ax::z))
                return;
            if ((alpha == Ax::x || beta == Ax::x) &&
                (alpha == Ax::t || beta == Ax::t))
                return;
            */
            if (alpha == Ax::y && beta == Ax::y)
                return (rs - pos[Ax::x]) * std::sin(pos[Ax::z]) *
                       std::sin(pos[Ax::z]);
            /*
            if ((alpha == Ax::y || beta == Ax::y) &&
                (alpha == Ax::z || beta == Ax::z))
                return;
            if ((alpha == Ax::y || beta == Ax::y) &&
                (alpha == Ax::t || beta == Ax::t))
                return;
            */
            if (alpha == Ax::z && beta == Ax::z) return rs - pos[Ax::x];
            /*
            if ((alpha == Ax::z || beta == Ax::z) &&
                (alpha == Ax::t || beta == Ax::t))
                return;
            */
            if (alpha == Ax::t && beta == Ax::t)
                return c * c * rs * (pos[Ax::x] - rs) /
                       (2 * pos[Ax::x] * pos[Ax::x] * pos[Ax::x]);
            return 0;
        case Ax::y:
            // if (alpha == Ax::x && beta == Ax::x) return;
            if ((alpha == Ax::x || beta == Ax::x) &&
                (alpha == Ax::y || beta == Ax::y))
                return 1 / pos[Ax::x];
            /*
            if ((alpha == Ax::x || beta == Ax::x) &&
                (alpha == Ax::z || beta == Ax::z))
                return;
            if ((alpha == Ax::x || beta == Ax::x) &&
                (alpha == Ax::t || beta == Ax::t))
                return;
            if (alpha == Ax::y && beta == Ax::y) return;
            */
            if ((alpha == Ax::y || beta == Ax::y) &&
                (alpha == Ax::z || beta == Ax::z))
                return 1.0 / std::tan(pos[Ax::z]);
            /*
            if ((alpha == Ax::y || beta == Ax::y) &&
                (alpha == Ax::t || beta == Ax::t))
                return;
            if (alpha == Ax::z && beta == Ax::z) return;
            if ((alpha == Ax::z || beta == Ax::z) &&
                (alpha == Ax::t || beta == Ax::t))
                return;
            if (alpha == Ax::t && beta == Ax::t) return;
            */
            return 0;
        case Ax::z:
            /*
            if (alpha == Ax::x && beta == Ax::x) return;
            if ((alpha == Ax::x || beta == Ax::x) &&
                (alpha == Ax::y || beta == Ax::y))
                return;
            */
            if ((alpha == Ax::x || beta == Ax::x) &&
                (alpha == Ax::z || beta == Ax::z))
                return 1 / pos[Ax::x];
            /*
            if ((alpha == Ax::x || beta == Ax::x) &&
                (alpha == Ax::t || beta == Ax::t))
                return;
            */
            if (alpha == Ax::y && beta == Ax::y)
                return -std::sin(pos[Ax::z]) * std::cos(pos[Ax::z]);
            /*
            if ((alpha == Ax::y || beta == Ax::y) &&
                (alpha == Ax::z || beta == Ax::z))
                return;
            if ((alpha == Ax::y || beta == Ax::y) &&
                (alpha == Ax::t || beta == Ax::t))
                return;
            if (alpha == Ax::z && beta == Ax::z) return;
            if ((alpha == Ax::z || beta == Ax::z) &&
                (alpha == Ax::t || beta == Ax::t))
                return;
            if (alpha == Ax::t && beta == Ax::t) return;
            */
            return 0;
        case Ax::t:
            /*
            if (alpha == Ax::x && beta == Ax::x) return;
            if ((alpha == Ax::x || beta == Ax::x) &&
                (alpha == Ax::y || beta == Ax::y))
                return;
            if ((alpha == Ax::x || beta == Ax::x) &&
                (alpha == Ax::z || beta == Ax::z))
                return;
            */
            if ((alpha == Ax::x || beta == Ax::x) &&
                (alpha == Ax::t || beta == Ax::t))
                return rs / (2 * pos[Ax::x] * (pos[Ax::x] - rs));
            /*
            if (alpha == Ax::y && beta == Ax::y) return;
            if ((alpha == Ax::y || beta == Ax::y) &&
                (alpha == Ax::z || beta == Ax::z))
                return;
            if ((alpha == Ax::y || beta == Ax::y) &&
                (alpha == Ax::t || beta == Ax::t))
                return;
            if (alpha == Ax::z && beta == Ax::z) return;
            if ((alpha == Ax::z || beta == Ax::z) &&
                (alpha == Ax::t || beta == Ax::t))
                return;
            if (alpha == Ax::t && beta == Ax::t) return;
            */
            return 0;
    }
    return 0;
}

template <typename T>
FVector<T> geodessic(const FVector<T>& pos, const FVector<T>& v) {
    FVector<T> res;
    for (int mu{0}; mu < FVector<>::size; ++mu) {
        for (int alpha{0}; alpha < FVector<>::size; ++alpha) {
            for (int beta{0}; beta < FVector<>::size; ++beta) {
                res[mu] +=
                    chr_symbols<T>(mu, alpha, beta, pos) * v[alpha] * v[beta];
                // std::cout << chr_symbols<T>(mu, alpha, beta, pos) <<
                // std::endl;
            }
        }
    }
    res = res * -1.0;
    // res.check_bounds();
    //  std::cout << "res: " << res << res * -1.0 << std::endl;
    return res;
}

template <typename T>
void geodessic_step(FVector<T>& pos, FVector<T>& v, const T h) {
    /*
      calculate runge-kutta nystroem factors --> solve initial value problem for
      second order differential equation
     */
    const FVector<T> k1 = geodessic<T>(pos, v);
    const FVector<T> yp1 = v + k1 * (h / 2);
    const FVector<T> y1 = pos + ((v + yp1) * (h / 4));

    const FVector<T> k2 = geodessic<T>(y1, yp1);
    const FVector<T> yp2 = v + k2 * (h / 2);
    const FVector<T> y2 = pos + ((v + yp2) * (h / 4));

    const FVector<T> k3 = geodessic<T>(y2, yp2);
    const FVector<T> yp3 = v + k3 * h;
    const FVector<T> y3 = pos + ((v + yp3) * (h / 2));
    // pos + (v + k3 * h) * h, v + k3 * h
    const FVector<T> k4 = geodessic<T>(y3, yp3);
    const FVector<T> yp4 = v + k4 * h;
    const FVector<T> y4 = pos + ((v + yp4) * (h / 2));
    /*
    std::cout << "v:" << v << " --> "
              << v + (k1 + k2 * 2 + k3 * 2 + k4) * (h / 6.0) << std::endl;
    std::cout << "v:" << v << " cart: " << v.to_cart() << std::endl;

    std::cout << "pos:" << pos << " --> "
              << pos + ((yp1 + yp2 * 2 + yp3 * 2 + yp4) * (h / 6.0))
              << std::endl;
    std::cout << "d pos/ds: " << ((yp1 + yp2 * 2 + yp3 * 2 + yp4) * (h / 6.0))
              << "->cart:"
              << ((yp1 + yp2 * 2 + yp3 * 2 + yp4) * (h / 6.0)).to_cart()
              << std::endl;
    */
    v = v + (k1 + k2 * 2 + k3 * 2 + k4) * (h / 6.0);
    pos = pos + ((yp1 + yp2 * 2 + yp3 * 2 + yp4) * (h / 6.0));
    // std::cout << yp1 << " " << yp2 * 2 << " " << yp3 * 2 << " " << yp4
    //           << std::endl;

    pos.check_bounds();

    // << ((yp1 + yp2 * 2 + yp3 * 2 + yp4) * (h / 6.0)) <<
}
